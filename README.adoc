:toc:

= JGroups OpenTelemetry Integration

Low-overhead OpenTelemetry metrics integration for JGroups with standardized names, UCUM units, and annotation-driven SPI for zero-configuration observability.

**https://rhusar.github.io/jgroups-opentelemetry/[API Documentation (Javadoc)]**

== Goals

This project provides a native OpenTelemetry exporter for JGroups that:

* *Standardized Metric Names*: Exports JGroups metrics with curated, semantic naming conventions that follow OpenTelemetry best practices
* *Defined Units*: All metrics include proper UCUM units (e.g., `{messages}`, `{bytes}`, `{connections}`) for consistent interpretation across observability platforms
* *Native Integration*: Integrates directly with the OpenTelemetry SDK without requiring JMX or external metric scrapers
* *Zero Configuration Observability API*: Automatically discovers and exports metrics from JGroups protocols in the stack
* *Extensible SPI*: Pluggable architecture using ServiceLoader allows custom protocol instrumentations to be added without modifying core code
* *Production Ready*: Designed for high-throughput, low-overhead metric collection in production environments

Unlike JMX-based monitoring, this integration provides:

* Direct programmatic access to JGroups internals
* Async metric collection with minimal performance impact
* Native support for modern observability backends (Prometheus, Grafana, Datadog, etc.)
* Semantic metric names aligned with OpenTelemetry conventions

== Implementation Roadmap

This project is designed with a multi-stage implementation approach to minimize changes to JGroups core while enabling future upstream integration.

=== Stage 1: External Integration (Current)

The current implementation operates entirely outside JGroups core:

* *No JGroups modifications required*: This library works with unmodified JGroups releases
* *Protocol-specific instrumentation*: Each protocol has a dedicated `MetricsInstrumentation` implementation (may use reflection to access internal fields)
* *Manual metric registration*: Metrics are explicitly registered in instrumentation classes (skips potentially annotated but useless or derived metrics)
* *Introduction of declarative, annotation-based approach*: e.g. `@Observable` annotation that can annotate fields and methods.


This approach allows immediate deployment without waiting for JGroups upstream acceptance.

==== Phase 2: Upstream Observability Annotations

Move the `org.jgroups.annotations.observability` package to JGroups core:

* Already uses the `org.jgroups.annotations` namespace for easy integration
* No external dependencies (pure Java annotations), hi Bela :-)
* Framework-agnostic design works with any metrics system while striving primarily for OpenTelemetry

==== Phase 3: Annotate Protocol Metrics

Internal and external protocol developers annotate observable fields and methods:

[source,java]
----
public class OBSERVABLE_PROTOCOL extends Protocol {
    @Observable(
        name = "messages.sent",
        type = ObservableType.COUNTER,
        unit = ObservableUnit.MESSAGES,
        description = "Total number of unicast messages sent"
    )
    protected final LongAdder num_msgs_sent = new LongAdder();
}
----

==== Generic Metric Discovery

Replace protocol-specific instrumentation with a single generic processor:

* `ObservableMetricsInstrumentationProcessor` scans for `@Observable` annotations
* Automatically registers metrics based on annotation metadata
* No manual instrumentation code needed per protocol
* Works across all metrics frameworks (OpenTelemetry, Micrometer, etc.)

==== Benefits

* *Single source of truth*: Metric definitions live with the code
* *Maintainability*: Metrics evolve automatically with protocol changes
* *Consistency*: Same metric definitions across all observability platforms
* *Reduced boilerplate*: No manual instrumentation classes needed
* *Type safety*: Compile-time validation of metric types and units

==== Migration Path

When JGroups adopts the SPI:

1. Remove manual `MetricsInstrumentation` implementations (e.g., `UNICAST3MetricsInstrumentation`)
2. Use generic `ObservableMetricsInstrumentationProcessor` for all protocols
3. Maintain backward compatibility during transition
4. Eventually remove reflection-based instrumentation

This roadmap ensures the project can deliver value immediately while building toward a more elegant, upstream-integrated solution.

NOTE: This will be moved to a separate DESIGN.adoc once this becomes irrelevant.

== Usage

=== Maven Dependency

[source,xml]
----
<dependency>
    <groupId>org.jgroups.opentelemetry</groupId>
    <artifactId>jgroups-opentelemetry</artifactId>
    <version>1.0.0.Alpha1-SNAPSHOT</version>
</dependency>
----

=== Adding to Protocol Stack

Add the `OPENTELEMETRY` protocol to your JGroups configuration:

[source,java]
----
// Configure OpenTelemetry SDK
SdkMeterProvider meterProvider = SdkMeterProvider.builder()
    .registerMetricReader(PeriodicMetricReader.builder(prometheusExporter)
        .setInterval(Duration.ofSeconds(60))
        .build())
    .build();

OpenTelemetry openTelemetry = OpenTelemetrySdk.builder()
    .setMeterProvider(meterProvider)
    .build();

// Create OPENTELEMETRY protocol with OpenTelemetry instance
OPENTELEMETRY otel = new OPENTELEMETRY()
    .setOpenTelemetry(openTelemetry);

// Add to protocol stack
JChannel channel = new JChannel(
    new UDP(),
    new PING(),
    new MERGE3(),
    new FD_SOCK(),
    new FD_ALL3(),
    new VERIFY_SUSPECT(),
    new NAKACK2(),
    otel,              // OpenTelemetry protocol
    new UNICAST3(),
    new STABLE(),
    new GMS(),
    new UFC(),
    new MFC(),
    new FRAG2()
).name("node1");

channel.connect("my-cluster");
----

=== XML Configuration

[source,xml]
----
<config>
    <UDP />
    <PING />
    <MERGE3 />
    <FD_SOCK />
    <FD_ALL3 />
    <VERIFY_SUSPECT />
    <NAKACK2 />
    <OPENTELEMETRY />
    <UNICAST3 />
    <STABLE />
    <GMS />
    <UFC />
    <MFC />
    <FRAG2 />
</config>
----

=== Programmatic Registration Without Protocol

For use cases without adding the OPENTELEMETRY protocol to the protocol stack, you can use `MetricsRegistrar` directly:

[source,java]
----
import org.jgroups.opentelemetry.impl.MetricsRegistrar;
import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.metrics.SdkMeterProvider;
import org.jgroups.JChannel;

// Configure OpenTelemetry SDK
SdkMeterProvider meterProvider = SdkMeterProvider.builder()
    .registerMetricReader(PeriodicMetricReader.builder(prometheusExporter)
        .setInterval(Duration.ofSeconds(60))
        .build())
    .build();

OpenTelemetry openTelemetry = OpenTelemetrySdk.builder()
    .setMeterProvider(meterProvider)
    .build();

// Create your JChannel without OPENTELEMETRY protocol
JChannel channel = new JChannel(
    new UDP(),
    new PING(),
    new NAKACK2(),
    new UNICAST3(),
    new STABLE(),
    new GMS()
).name("node1");

// Connect the channel
channel.connect("my-cluster");

// Register metrics programmatically
MetricsRegistrar.registerMetrics(
    openTelemetry,
    channel.getProtocolStack(),
    "org.jgroups"  // instrumentation scope name
);
----

== Protocol Configuration

The `OPENTELEMETRY` protocol supports the following configuration properties:

[cols="2,1,2,4"]
|===
|Property |Type |Default |Description

|`instrumentationScopeName`
|String
|`org.jgroups`
|Instrumentation scope name for the OpenTelemetry meter. Can be set via system property `jgroups.opentelemetry.scope_name` or environment variable `JGROUPS_OPENTELEMETRY_SCOPE_NAME`

|`exposeConfigurationMetrics`
|boolean
|`true`
|Whether to expose protocol configuration values as metrics (e.g., thresholds, enabled flags, capacity limits). Configuration metrics provide important context for understanding operational metrics and detecting configuration drift across cluster nodes. Can be set via system property `jgroups.opentelemetry.expose_configuration_metrics` or environment variable `JGROUPS_OPENTELEMETRY_EXPOSE_CONFIGURATION_METRICS`
|===

== Exported Metrics

=== UNICAST3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.unicast3.messages.sent`
|Counter
|`{messages}`
|Total number of unicast messages sent. Throughput indicator for outgoing traffic

|`jgroups.unicast3.messages.received`
|Counter
|`{messages}`
|Total number of unicast messages received. Throughput indicator for incoming traffic

|`jgroups.unicast3.retransmissions`
|Counter
|`{messages}`
|Number of messages retransmitted. *Critical*: High values indicate network packet loss or congestion

|`jgroups.unicast3.xmit_requests.sent`
|Counter
|`{requests}`
|Number of retransmit requests sent to other nodes. Indicates this node detected missing messages from senders

|`jgroups.unicast3.xmit_requests.received`
|Counter
|`{requests}`
|Number of retransmit requests received from other nodes. Indicates other nodes are detecting packet loss from this node

|`jgroups.unicast3.acks.sent`
|Counter
|`{acks}`
|Number of acknowledgments sent. Protocol overhead metric

|`jgroups.unicast3.acks.received`
|Counter
|`{acks}`
|Number of acknowledgments received. Protocol overhead metric

|`jgroups.unicast3.connections`
|Gauge
|`{connections}`
|Total number of connections. Connection pool size (send + receive)

|`jgroups.unicast3.connections.send`
|Gauge
|`{connections}`
|Number of active outgoing send connections. Connection pool size for sends

|`jgroups.unicast3.connections.receive`
|Gauge
|`{connections}`
|Number of active incoming receive connections. Connection pool size for receives

|`jgroups.unicast3.messages.unacked`
|Gauge
|`{messages}`
|Number of unacknowledged messages in send windows. *Critical*: Indicates backpressure or slow receivers

|`jgroups.unicast3.xmit_table.missing_messages`
|Gauge
|`{messages}`
|Number of missing (not yet received) messages in receive windows. *Critical*: Indicates gaps in message sequence

|`jgroups.unicast3.xmit_table.undelivered_messages`
|Gauge
|`{messages}`
|Total undelivered messages buffered in all receive windows. Memory pressure and delivery lag indicator
|===


=== VERIFY_SUSPECT2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.verify_suspect2.suspects`
|Gauge
|`{members}`
|Number of currently suspected members being verified. *Critical*: Indicates members under suspicion verification

|`jgroups.verify_suspect2.verification_task_running`
|Gauge
|`1` (dimensionless)
|Indicates whether the verification task is currently running (1=running, 0=stopped). Task activity indicator
|===


=== FILE_PING-Based Discovery Protocol Metrics (Common)

Applies to: FILE_PING, JDBC_PING, JDBC_PING2, RACKSPACE_PING, SWIFT_PING

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.<protocol>.writes`
|Gauge
|`{operations}`
|Number of times discovery information was written. Storage update frequency indicator (database, filesystem, cloud storage, etc.)

|`jgroups.<protocol>.reads`
|Gauge
|`{operations}`
|Number of times discovery information was read. Storage read frequency indicator

|`jgroups.<protocol>.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator. Protocol name is lowercase (e.g., `jgroups.file_ping.is_coord`, `jgroups.jdbc_ping.is_coord`)
|===

NOTE: FILE_PING-based protocols use persistent storage (file system, database, cloud storage) to share cluster membership information. The `writes` and `reads` metrics help monitor the frequency of storage operations, which can be important for troubleshooting discovery issues or optimizing storage backend performance.

=== Discovery Protocol Metrics (Common)

Applies to: PING, BPING, MPING, DNS_PING, TCPPING, TCPGOSSIP, SHARED_LOOPBACK_PING, and all FILE_PING-based protocols listed above

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.<protocol>.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator. Protocol name is lowercase (e.g., `jgroups.ping.is_coord`, `jgroups.dns_ping.is_coord`)

|`jgroups.<protocol>.discovery_requests`
|Gauge
|`{requests}`
|Number of discovery requests sent. Discovery activity indicator. Tracks how often this node initiates discovery to find cluster members
|===

=== MERGE3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.merge3.views.cached`
|Gauge
|`1` (dimensionless)
|Number of cached ViewIds from different subgroups. Indicates potential network partitions detected

|`jgroups.merge3.merge_events`
|Counter
|`1` (dimensionless)
|Number of times a MERGE event was sent up the stack. Tracks merge operations initiated

|`jgroups.merge3.view_consistency_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the view consistency checker task is running (1=running, 0=stopped). Task activity indicator

|`jgroups.merge3.info_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the info sender task is running (1=running, 0=stopped). Task activity indicator

|`jgroups.merge3.interval.min`
|Gauge (Configuration)
|`{milliseconds}`
|Minimum time in milliseconds before sending an info message

|`jgroups.merge3.interval.max`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum interval in milliseconds when the next info message will be sent

|`jgroups.merge3.interval.check`
|Gauge (Configuration)
|`{milliseconds}`
|Interval in milliseconds after which we check for view inconsistencies

|`jgroups.merge3.max_participants_in_merge`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of merge participants to be involved in a merge (0=unlimited)
|===

=== FD_SOCK Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_sock.suspects`
|Gauge
|`1` (dimensionless)
|Number of currently suspected members

|`jgroups.fd_sock.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events generated

|`jgroups.fd_sock.monitor.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the node crash detection monitor is running (1=running, 0=stopped)

|`jgroups.fd_sock.timeout.get_cache`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout for getting socket cache from coordinator

|`jgroups.fd_sock.timeout.sock_conn`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum time to wait for ping Socket.connect() to return

|`jgroups.fd_sock.interval.suspect_msg`
|Gauge (Configuration)
|`{milliseconds}`
|Interval for broadcasting suspect messages

|`jgroups.fd_sock.cache.max_elements`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of elements in the cache until deleted elements are removed

|`jgroups.fd_sock.cache.max_age`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum age an element marked as removed has to have until it is removed

|`jgroups.fd_sock.num_tries`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of attempts coordinator is solicited for socket cache until we give up

|`jgroups.fd_sock.port.start`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for server socket (0 picks random port)

|`jgroups.fd_sock.port.client_bind`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for client socket (0 picks random port)

|`jgroups.fd_sock.port.range`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of ports to probe for start_port and client_bind_port

|`jgroups.fd_sock.keep_alive`
|Gauge (Configuration)
|`1` (dimensionless)
|Whether to use KEEP_ALIVE on the ping socket (1=enabled, 0=disabled)
|===

NOTE: FD_SOCK uses TCP sockets for ring-based failure detection. Each member monitors its neighbor on the right by maintaining a socket connection. Socket closure indicates failure. The configuration metrics help tune connection parameters and cache behavior.

=== FD_SOCK2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_sock2.suspects`
|Gauge
|`1` (dimensionless)
|Number of currently suspected members

|`jgroups.fd_sock2.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events generated

|`jgroups.fd_sock2.offset`
|Gauge (Configuration)
|`1` (dimensionless)
|Offset from the transport's bind port

|`jgroups.fd_sock2.port.range`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of ports to probe for finding a free port

|`jgroups.fd_sock2.port.client_bind`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for client socket (0 picks random port)

|`jgroups.fd_sock2.port.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Lowest port the FD_SOCK2 server can listen on

|`jgroups.fd_sock2.port.max`
|Gauge (Configuration)
|`1` (dimensionless)
|Highest port the FD_SOCK2 server can listen on

|`jgroups.fd_sock2.interval.suspect_msg`
|Gauge (Configuration)
|`{milliseconds}`
|Interval for broadcasting suspect messages

|`jgroups.fd_sock2.timeout.connect`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum time to wait for a connect attempt

|`jgroups.fd_sock2.linger`
|Gauge (Configuration)
|`{seconds}`
|SO_LINGER in seconds (-1 disables it)
|===

NOTE: FD_SOCK2 is the successor to FD_SOCK, using NIO-based TCP connections for failure detection. It provides improved performance and scalability. The configuration metrics help tune port ranges and connection timeouts.

=== FD_ALL3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all3.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all3.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all3.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all3.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all3.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all3.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all3.timeout`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all3.interval`
|Gauge (Configuration)
|`{milliseconds}`
|Interval at which a heartbeat is sent to the cluster

|`jgroups.fd_all3.num_bits`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of bits for each member (timeout / interval)
|===

NOTE: FD_ALL3 uses bitmap-based heartbeat failure detection. Every member periodically multicasts a heartbeat. Each member maintains a bitmap for all other members, with bits set to 1 on heartbeat reception and advanced to 0 on each interval. When all bits are 0, the member is suspected. The configuration metrics help tune the detection sensitivity through timeout and interval settings.

=== FD_ALL Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all.timeout`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all.interval`
|Gauge (Configuration)
|`{milliseconds}`
|Interval at which a heartbeat is sent to the cluster

|`jgroups.fd_all.timeout_check_interval`
|Gauge (Configuration)
|`{milliseconds}`
|Interval at which the heartbeat timeouts are checked

|`jgroups.fd_all.use_time_service`
|Gauge (Configuration)
|`1` (dimensionless)
|Whether to use TimeService for timestamps (1=enabled, 0=disabled)
|===

NOTE: FD_ALL uses timestamp-based heartbeat failure detection. Every member periodically multicasts a heartbeat and maintains a timestamp table for all other members. When a heartbeat or data is received from a member, their timestamp is updated. The timeout checker periodically checks for expired timestamps to identify suspected members.

=== FD_ALL2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all2.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all2.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all2.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all2.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all2.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all2.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all2.timeout`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all2.interval`
|Gauge (Configuration)
|`{milliseconds}`
|Interval at which a heartbeat is sent to the cluster
|===

NOTE: FD_ALL2 uses flag-based heartbeat failure detection. Every member periodically multicasts a heartbeat and maintains a boolean flag for all other members. When a heartbeat or data is received, the flag is set to true. The timeout checker periodically checks flags - if false (no heartbeat received within timeout), the member is suspected and the flag is reset to false for the next interval.

=== UFC Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.ufc.credit.requests.received`
|Counter
|`{requests}`
|Number of credit requests received from senders

|`jgroups.ufc.credit.requests.sent`
|Counter
|`{requests}`
|Number of credit requests sent to receivers

|`jgroups.ufc.credit.responses.received`
|Counter
|`{requests}`
|Number of credit responses (replenishments) received from receivers

|`jgroups.ufc.credit.responses.sent`
|Counter
|`{requests}`
|Number of credit responses (replenishments) sent to senders

|`jgroups.ufc.blocked`
|Gauge
|`1` (dimensionless)
|Number of times flow control blocked a sender waiting for credits. *Critical*: High values indicate backpressure

|`jgroups.ufc.blocked.avg`
|Gauge
|`ms` (milliseconds)
|Average time in milliseconds that senders were blocked waiting for credits. *Critical*: High values indicate credit starvation

|`jgroups.ufc.credits.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum number of bytes to send per receiver before credits must be replenished

|`jgroups.ufc.credits.min`
|Gauge (Configuration)
|`By` (bytes)
|Threshold at which a receiver sends more credits to a sender

|`jgroups.ufc.credits.threshold.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Threshold (as percentage of max_credits) at which a receiver sends more credits

|`jgroups.ufc.blocked.max`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum time in milliseconds to block waiting for credits before sending a replenishment request
|===

NOTE: UFC (Unicast Flow Control) is a credit-based flow control protocol for unicast messages. Each sender has a credit budget (in bytes) per receiver. When credits are exhausted, the sender blocks until credits are replenished by the receiver. This prevents fast senders from overwhelming slow receivers with unicast traffic.

=== MFC Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.mfc.credit.requests.received`
|Counter
|`{requests}`
|Number of credit requests received from senders

|`jgroups.mfc.credit.requests.sent`
|Counter
|`{requests}`
|Number of credit requests sent to receivers

|`jgroups.mfc.credit.responses.received`
|Counter
|`{requests}`
|Number of credit responses (replenishments) received from receivers

|`jgroups.mfc.credit.responses.sent`
|Counter
|`{requests}`
|Number of credit responses (replenishments) sent to senders

|`jgroups.mfc.blocked`
|Gauge
|`1` (dimensionless)
|Number of times flow control blocked a sender waiting for credits. *Critical*: High values indicate backpressure

|`jgroups.mfc.blocked.avg`
|Gauge
|`ns` (nanoseconds)
|Average time in nanoseconds that senders were blocked waiting for credits. *Critical*: High values indicate credit starvation

|`jgroups.mfc.credits.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum number of bytes to send per receiver before credits must be replenished

|`jgroups.mfc.credits.min`
|Gauge (Configuration)
|`By` (bytes)
|Threshold at which a receiver sends more credits to a sender

|`jgroups.mfc.credits.threshold.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Threshold (as percentage of max_credits) at which a receiver sends more credits

|`jgroups.mfc.blocked.max`
|Gauge (Configuration)
|`{milliseconds}`
|Maximum time in milliseconds to block waiting for credits before sending a replenishment request
|===

NOTE: MFC (Multicast Flow Control) is a credit-based flow control protocol for multicast messages. It maintains a shared credit pool across all cluster members. When sending a multicast message, the sender decrements credits for all receivers. If any receiver's credits are exhausted, the sender blocks. This prevents fast senders from overwhelming slow receivers with multicast traffic.

=== GMS Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.pbcast.gms.views`
|Gauge
|`1` (dimensionless)
|Total number of views installed in this member. View installation tracking indicator

|`jgroups.pbcast.gms.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator

|`jgroups.pbcast.gms.is_leaving`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is in the process of leaving (1=leaving, 0=not leaving). Member departure indicator

|`jgroups.pbcast.gms.merge.in_progress`
|Gauge
|`1` (dimensionless)
|Indicates whether a merge is currently in progress (1=merging, 0=not merging). *Critical*: Merge activity indicator

|`jgroups.pbcast.gms.merge.task.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the merge task is currently running (1=running, 0=stopped). Merge task activity indicator

|`jgroups.pbcast.gms.merge.killer.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the merge killer task is currently running (1=running, 0=stopped). Merge timeout task activity indicator

|`jgroups.pbcast.gms.view_handler.queue`
|Gauge
|`1` (dimensionless)
|Number of queued view change requests (JOIN/LEAVE/SUSPECT) waiting to be processed. *Critical*: High values indicate processing backlog

|`jgroups.pbcast.gms.view_handler.suspended`
|Gauge
|`1` (dimensionless)
|Indicates whether the view handler is suspended (1=suspended, 0=active). Handler activity indicator

|`jgroups.pbcast.gms.timeout.join`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout in milliseconds for join operations

|`jgroups.pbcast.gms.timeout.leave`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout in milliseconds for leave operations

|`jgroups.pbcast.gms.timeout.merge`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout in milliseconds to complete merge operations

|`jgroups.pbcast.gms.timeout.view_ack_collection`
|Gauge (Configuration)
|`{milliseconds}`
|Timeout in milliseconds to wait for all VIEW acks (0 means wait forever)

|`jgroups.pbcast.gms.join_attempts.max`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of join attempts before giving up and becoming singleton (0 means never give up)
|===

NOTE: GMS (Group Membership Service) is the core protocol responsible for maintaining cluster membership. It handles member joins, leaves, crashes (via suspicions), and network partition merges. The protocol maintains views (snapshots of cluster membership) and ensures all members have consistent view of the cluster. View changes are coordinated by the cluster coordinator (the first member in the view).

=== STABLE Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.pbcast.stable.stable.sent`
|Counter
|`{messages}`
|Number of STABLE messages sent (digest reports to coordinator).

|`jgroups.pbcast.stable.stable.received`
|Counter
|`{messages}`
|Number of STABLE messages received (digest reports from members).

|`jgroups.pbcast.stable.stability.sent`
|Counter
|`{messages}`
|Number of STABILITY messages sent (garbage collection triggers).

|`jgroups.pbcast.stable.stability.received`
|Counter
|`{messages}`
|Number of STABILITY messages received (garbage collection triggers).

|`jgroups.pbcast.stable.bytes.received`
|Gauge
|`By` (bytes)
|Total bytes accumulated from multicast messages since last STABLE message.

|`jgroups.pbcast.stable.votes`
|Gauge
|`1` (dimensionless)
|Number of STABLE votes received for current digest.

|`jgroups.pbcast.stable.suspended`
|Gauge
|`1` (dimensionless)
|Indicates whether garbage collection is suspended (1=suspended, 0=active).

|`jgroups.pbcast.stable.stable_task.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the stable task is running (1=running, 0=stopped).

|`jgroups.pbcast.stable.gossip.avg`
|Gauge (Configuration)
|`{milliseconds}`
|Average interval in milliseconds between STABLE gossip messages (0 disables periodic gossip)

|`jgroups.pbcast.stable.bytes.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum bytes from multicast messages before triggering STABLE message (0 disables byte-based triggering)
|===

== Building

[source,bash]
----
./mvnw clean install
----

== Requirements

* Java 17 or higher
* JGroups 5.4.4.Final or higher
* OpenTelemetry Java SDK 1.44.1 or higher

== Future Work

=== Support for Fine-Grained Metric Control

Add support for enabling/disabling individual metrics at runtime:

* Add `enabled` parameter to `@Observable` annotation to allow metrics to be conditionally registered
* Support configuration-based filtering (e.g., via property patterns or metric name prefixes)
* Enable/disable metrics dynamically without requiring code changes or protocol restarts

This would allow users to reduce overhead by disabling metrics they don't need while keeping the annotation metadata in place for documentation purposes.

=== Create an Observability Best Practices Guide

Create comprehensive documentation on monitoring JGroups clusters effectively:

* *Main Performance Indicators*: Document critical metrics to watch for cluster health (e.g., retransmission rates, unacknowledged message counts, database operation failures)
* *Problem Detection Patterns*: Identify metric patterns that indicate specific issues (e.g., high retransmissions suggesting network problems, growing unacked messages indicating backpressure)
* *Remediation Strategies*: Provide actionable solutions for common problems detected through metrics
* *Alert Thresholds*: Recommend baseline alert thresholds for production environments
* *Troubleshooting Workflows*: Step-by-step guides for diagnosing issues using metric correlations
* *Performance Tuning*: Best practices for optimizing JGroups configuration based on observed metrics

This would help operators move from raw metric collection to actionable insights, enabling proactive issue detection and faster incident resolution.

== License

Licensed under the Apache License, Version 2.0. See link:LICENSE[LICENSE] file for details.

== Contributing

Contributions are welcome! Please submit issues and pull requests on GitHub.
