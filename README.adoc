:toc:

= JGroups OpenTelemetry Integration

Low-overhead OpenTelemetry metrics integration for JGroups with standardized names, UCUM units, and annotation-driven SPI for zero-configuration observability.

**https://rhusar.github.io/jgroups-opentelemetry/[API Documentation (Javadoc)]**

== Goals

This project provides a native OpenTelemetry exporter for JGroups that:

* *Out-of-the-Box OpenTelemetry Protocol (OTLP) Export*: Drop-in OpenTelemetry metrics export for vanilla JGroups and Infinispan (library mode)
* *Standardized Metric Names*: Exports JGroups metrics with curated, semantic naming conventions that follow OpenTelemetry best practices
* *Defined Units*: All metrics include proper UCUM units (e.g., `s`, `ms`, `By`, `{messages}`, dimensionless, etc.) for consistent interpretation across observability platforms
* *Zero Configuration Observability API*: Automatically discovers and exports metrics from JGroups protocols in the stack
* *Native Integration*: Integrates directly with the OpenTelemetry SDK without requiring JMX or external metric scrapers
* *Extensible SPI*: Pluggable architecture using ServiceLoader allows custom protocol instrumentation to be added without modifying core code
* *Production Ready*: Designed for high-throughput, low-overhead metric collection in production environments

Unlike JMX-based monitoring, this integration provides:

* Direct programmatic access to JGroups internals
* Async metric collection with minimal performance impact
* Native support for modern observability backends (Prometheus, Grafana, Datadog, etc.)
* Semantic metric names aligned with OpenTelemetry conventions

== Implementation Roadmap

This project is designed with a multi-stage implementation approach to minimize changes to JGroups core while enabling future upstream integration.

=== Stage 1: External Integration (Current)

The current implementation operates entirely outside JGroups core:

* *No JGroups modifications required*: This library works with unmodified JGroups releases
* *Protocol-specific instrumentation*: Each protocol has a dedicated `MetricsInstrumentation` implementation (may use reflection to access internal fields)
* *Manual metric registration*: Metrics are explicitly registered in instrumentation classes (skips potentially annotated but useless or derived metrics)
* *Introduction of declarative, annotation-based approach*: e.g. `@Observable` annotation that can annotate fields and methods.


This approach allows immediate deployment without waiting for JGroups upstream acceptance.

=== Phase 2: Upstream Observability Annotations

Move the `org.jgroups.annotations.observability` package to JGroups core:

* Already uses the `org.jgroups.annotations` namespace for easy integration
* No external dependencies (pure Java annotations), hi Bela :-)
* Framework-agnostic design works with any metrics system while striving primarily for OpenTelemetry

=== Phase 3: Annotate Protocol Metrics

Internal and external protocol developers annotate observable fields and methods:

[source,java]
----
public class OBSERVABLE_PROTOCOL extends Protocol {
    @Observable(
        name = "messages.sent", // "jgroups.observable_protocol." is prefixed automatically
        type = ObservableType.COUNTER,
        unit = ObservableUnit.MESSAGES,
        description = "Total number of unicast messages sent"
    )
    protected final LongAdder num_msgs_sent = new LongAdder();
}
----

=== Generic Metric Discovery

Replace protocol-specific instrumentation with a single generic processor:

* `ObservableMetricsInstrumentationProcessor` scans for `@Observable` annotations
* Automatically registers metrics based on annotation metadata
* No manual instrumentation code needed per protocol
* Works across all metrics frameworks (OpenTelemetry, Micrometer, etc.)

==== Benefits

* *Single source of truth*: Metric definitions live with the code
* *Maintainability*: Metrics evolve automatically with protocol changes
* *Consistency*: Same metric definitions across all observability platforms
* *Reduced boilerplate*: No manual instrumentation classes needed
* *Type safety*: Compile-time validation of metric types and units

==== Migration Path

When JGroups adopts the SPI:

1. Remove manual `MetricsInstrumentation` implementations (e.g., `UNICAST3MetricsInstrumentation`)
2. Use generic `ObservableMetricsInstrumentationProcessor` for all protocols
3. Maintain backward compatibility during transition
4. Eventually remove reflection-based instrumentation
5. Most importantly â€“ keep in place existing testing infrastructure as they will continue verifying metrics are still being exported.

This roadmap ensures the project can deliver value immediately while building toward a more elegant, upstream-integrated solution.

NOTE: This will be moved to a separate `DESIGN.adoc` once this becomes irrelevant.

== Quick Start Demo

The fastest way to see JGroups OpenTelemetry in action is to run the included demo with Grafana visualization.

See **link:demo/README.adoc[demo/README.adoc]** for complete instructions on running the demo with OpenTelemetry Collector, Prometheus, and Grafana.

== Usage

=== Maven Dependency

[source,xml]
----
<dependency>
    <groupId>org.jgroups.opentelemetry</groupId>
    <artifactId>jgroups-opentelemetry</artifactId>
    <version>1.0.0.Alpha1-SNAPSHOT</version>
</dependency>
----

=== Adding to Protocol Stack

The simplest way to integrate is to add the protocol and let it auto-configure OpenTelemetry SDK with endpoint,
via XML configuration with system properties:

[source,xml]
----
<config>
    <UDP />
    <PING />
    <NAKACK2 />
    <OPENTELEMETRY endpoint="http://localhost:4317" export_interval="30000" />
    <UNICAST3 />
    <STABLE />
    <GMS />
</config>
----

or programmatically:

[source,java]
----
// Create OPENTELEMETRY protocol with OTLP endpoint - SDK will be auto-configured
OPENTELEMETRY otel =

JChannel channel = new JChannel(
    new UDP(),
    new PING(),
    new NAKACK2(),
    new OPENTELEMETRY()
        .setEndpoint("http://localhost:4317")     // OTLP gRPC endpoint
        .setExportInterval(30000),                // Export every 30 seconds
    new UNICAST3(),
    new STABLE(),
    new GMS()
).name("my-node");

channel.connect("my-cluster");
----

The protocol will automatically create and manage the OpenTelemetry SDK lifecycle.
When the protocol is destroyed, the SDK will be properly cleaned up.

=== Programmatic Registration without using `OPENTELEMETRY` protocol

For use cases without adding the OPENTELEMETRY protocol to the protocol stack,
such as for a server/container-managed JGroups stack, you can use `MetricsRegistrar` directly:

[source,java]
----
// Create your JChannel without OPENTELEMETRY protocol
JChannel channel = new JChannel(...);

// Register metrics programmatically
MetricsRegistrar.registerMetrics(openTelemetryInstance, channel.getProtocolStack(), "org.jgroups");
----

== Protocol Configuration

The `OPENTELEMETRY` protocol supports the following configuration properties:

[cols="2,1,2,4"]
|===
|Property |Type |Default |Description

|`instrumentationScopeName`
|String
|`org.jgroups`
|Instrumentation scope name for the OpenTelemetry meter. Can be set via system property `jgroups.opentelemetry.scope_name` or environment variable `JGROUPS_OPENTELEMETRY_SCOPE_NAME`

|`exposeConfigurationMetrics`
|boolean
|`true`
|Whether to expose protocol configuration values as metrics (e.g., thresholds, enabled flags, capacity limits). Configuration metrics provide important context for understanding operational metrics and detecting configuration drift across cluster nodes. Can be set via system property `jgroups.opentelemetry.expose_configuration_metrics` or environment variable `JGROUPS_OPENTELEMETRY_EXPOSE_CONFIGURATION_METRICS`

|`endpoint`
|String
|`null`
|OTLP endpoint URL for metrics export (e.g., `http://localhost:4317`). If set, the protocol will automatically configure an OpenTelemetry SDK with OTLP gRPC exporter. If not set and no OpenTelemetry instance is provided programmatically, falls back to `GlobalOpenTelemetry.get()`. Can be set via system property `jgroups.opentelemetry.endpoint` or environment variable `JGROUPS_OPENTELEMETRY_ENDPOINT`

|`exportInterval`
|long
|`60000`
|Interval in milliseconds for periodic metric export when using auto-configured SDK. Only applies when `endpoint` is configured. Can be set via system property `jgroups.opentelemetry.export_interval` or environment variable `JGROUPS_OPENTELEMETRY_EXPORT_INTERVAL`

|`enableMessageSizeHistogram`
|boolean
|`false`
|Enable message size histogram tracking (OpenTelemetry-native replacement for SIZE/SIZE2 protocols). Records distribution of sent and received message sizes for performance analysis. *Disabled by default* due to performance overhead on high-throughput systems. Can be set via system property `jgroups.opentelemetry.enable_message_size_histogram` or environment variable `JGROUPS_OPENTELEMETRY_ENABLE_MESSAGE_SIZE_HISTOGRAM`

|`useTotalSize`
|boolean
|`false`
|When true, use `Message.size()` for histogram (includes headers), otherwise use `Message.getLength()` (payload only). Only relevant when `enableMessageSizeHistogram` is true
|===

NOTE: The message size histogram feature is an OpenTelemetry-native replacement for the SIZE/SIZE2 protocols. It uses native OpenTelemetry histograms with automatic bucket selection, making the data directly compatible with modern observability platforms without manual bucket configuration.

== Exported Metrics

=== Discovery Protocol Metrics (Common)

Applies to: PING, BPING, MPING, DNS_PING, TCPPING, TCPGOSSIP, SHARED_LOOPBACK_PING, and all FILE_PING-based protocols listed above

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.<protocol>.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator. Protocol name is lowercase (e.g., `jgroups.ping.is_coord`, `jgroups.dns_ping.is_coord`)

|`jgroups.<protocol>.discovery_requests`
|Gauge
|`{requests}`
|Number of discovery requests sent. Discovery activity indicator. Tracks how often this node initiates discovery to find cluster members
|===


=== FILE_PING-Based Discovery Protocol Metrics (Common)

Applies to: FILE_PING, JDBC_PING, JDBC_PING2, RACKSPACE_PING, SWIFT_PING

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.<protocol>.writes`
|Gauge
|`{operations}`
|Number of times discovery information was written. Storage update frequency indicator (database, filesystem, cloud storage, etc.)

|`jgroups.<protocol>.reads`
|Gauge
|`{operations}`
|Number of times discovery information was read. Storage read frequency indicator

|`jgroups.<protocol>.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator. Protocol name is lowercase (e.g., `jgroups.file_ping.is_coord`, `jgroups.jdbc_ping.is_coord`)
|===


=== MERGE3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.merge3.views.cached`
|Gauge
|`1` (dimensionless)
|Number of cached ViewIds from different subgroups. Indicates potential network partitions detected

|`jgroups.merge3.merge_events`
|Counter
|`1` (dimensionless)
|Number of times a MERGE event was sent up the stack. Tracks merge operations initiated

|`jgroups.merge3.view_consistency_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the view consistency checker task is running (1=running, 0=stopped). Task activity indicator

|`jgroups.merge3.info_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the info sender task is running (1=running, 0=stopped). Task activity indicator

|`jgroups.merge3.interval.min`
|Gauge (Configuration)
|`ms`
|Minimum time in milliseconds before sending an info message

|`jgroups.merge3.interval.max`
|Gauge (Configuration)
|`ms`
|Maximum interval in milliseconds when the next info message will be sent

|`jgroups.merge3.interval.check`
|Gauge (Configuration)
|`ms`
|Interval in milliseconds after which we check for view inconsistencies

|`jgroups.merge3.max_participants_in_merge`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of merge participants to be involved in a merge (0=unlimited)
|===


=== FD_SOCK Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_sock.suspects`
|Gauge
|`1` (dimensionless)
|Number of currently suspected members

|`jgroups.fd_sock.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events generated

|`jgroups.fd_sock.monitor.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the node crash detection monitor is running (1=running, 0=stopped)

|`jgroups.fd_sock.timeout.get_cache`
|Gauge (Configuration)
|`ms`
|Timeout for getting socket cache from coordinator

|`jgroups.fd_sock.timeout.sock_conn`
|Gauge (Configuration)
|`ms`
|Maximum time to wait for ping Socket.connect() to return

|`jgroups.fd_sock.interval.suspect_msg`
|Gauge (Configuration)
|`ms`
|Interval for broadcasting suspect messages

|`jgroups.fd_sock.cache.max_elements`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of elements in the cache until deleted elements are removed

|`jgroups.fd_sock.cache.max_age`
|Gauge (Configuration)
|`ms`
|Maximum age an element marked as removed has to have until it is removed

|`jgroups.fd_sock.num_tries`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of attempts coordinator is solicited for socket cache until we give up

|`jgroups.fd_sock.port.start`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for server socket (0 picks random port)

|`jgroups.fd_sock.port.client_bind`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for client socket (0 picks random port)

|`jgroups.fd_sock.port.range`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of ports to probe for start_port and client_bind_port

|`jgroups.fd_sock.keep_alive`
|Gauge (Configuration)
|`1` (dimensionless)
|Whether to use KEEP_ALIVE on the ping socket (1=enabled, 0=disabled)
|===


=== FD_SOCK2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_sock2.suspects`
|Gauge
|`1` (dimensionless)
|Number of currently suspected members

|`jgroups.fd_sock2.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events generated

|`jgroups.fd_sock2.offset`
|Gauge (Configuration)
|`1` (dimensionless)
|Offset from the transport's bind port

|`jgroups.fd_sock2.port.range`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of ports to probe for finding a free port

|`jgroups.fd_sock2.port.client_bind`
|Gauge (Configuration)
|`1` (dimensionless)
|Start port for client socket (0 picks random port)

|`jgroups.fd_sock2.port.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Lowest port the FD_SOCK2 server can listen on

|`jgroups.fd_sock2.port.max`
|Gauge (Configuration)
|`1` (dimensionless)
|Highest port the FD_SOCK2 server can listen on

|`jgroups.fd_sock2.interval.suspect_msg`
|Gauge (Configuration)
|`ms`
|Interval for broadcasting suspect messages

|`jgroups.fd_sock2.timeout.connect`
|Gauge (Configuration)
|`ms`
|Maximum time to wait for a connect attempt

|`jgroups.fd_sock2.linger`
|Gauge (Configuration)
|`s`
|SO_LINGER in seconds (-1 disables it)
|===


=== FD_ALL3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all3.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all3.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all3.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all3.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all3.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all3.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all3.timeout`
|Gauge (Configuration)
|`ms`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all3.interval`
|Gauge (Configuration)
|`ms`
|Interval at which a heartbeat is sent to the cluster

|`jgroups.fd_all3.num_bits`
|Gauge (Configuration)
|`1` (dimensionless)
|Number of bits for each member (timeout / interval)
|===


=== FD_ALL Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all.timeout`
|Gauge (Configuration)
|`ms`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all.interval`
|Gauge (Configuration)
|`ms`
|Interval at which a heartbeat is sent to the cluster

|`jgroups.fd_all.timeout_check_interval`
|Gauge (Configuration)
|`ms`
|Interval at which the heartbeat timeouts are checked

|`jgroups.fd_all.use_time_service`
|Gauge (Configuration)
|`1` (dimensionless)
|Whether to use TimeService for timestamps (1=enabled, 0=disabled)
|===


=== FD_ALL2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.fd_all2.heartbeats.sent`
|Counter
|`{messages}`
|Number of heartbeats sent

|`jgroups.fd_all2.heartbeats.received`
|Counter
|`{messages}`
|Number of heartbeats received

|`jgroups.fd_all2.suspect_events`
|Counter
|`1` (dimensionless)
|Number of suspect events sent

|`jgroups.fd_all2.has_suspected_members`
|Gauge
|`1` (dimensionless)
|Indicates whether there are currently any suspected members (1=yes, 0=no)

|`jgroups.fd_all2.timeout_checker.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the timeout checker task is running (1=running, 0=stopped)

|`jgroups.fd_all2.heartbeat_sender.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the heartbeat sender task is running (1=running, 0=stopped)

|`jgroups.fd_all2.timeout`
|Gauge (Configuration)
|`ms`
|Timeout after which a node is suspected if no heartbeat or data received

|`jgroups.fd_all2.interval`
|Gauge (Configuration)
|`ms`
|Interval at which a heartbeat is sent to the cluster
|===


=== VERIFY_SUSPECT2 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.verify_suspect2.suspects`
|Gauge
|`{members}`
|Number of currently suspected members being verified. *Critical*: Indicates members under suspicion verification

|`jgroups.verify_suspect2.verification_task_running`
|Gauge
|`1` (dimensionless)
|Indicates whether the verification task is currently running (1=running, 0=stopped). Task activity indicator
|===


=== UNICAST3 Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.unicast3.messages.sent`
|Counter
|`{messages}`
|Total number of unicast messages sent. Throughput indicator for outgoing traffic

|`jgroups.unicast3.messages.received`
|Counter
|`{messages}`
|Total number of unicast messages received. Throughput indicator for incoming traffic

|`jgroups.unicast3.retransmissions`
|Counter
|`{messages}`
|Number of messages retransmitted. *Critical*: High values indicate network packet loss or congestion

|`jgroups.unicast3.xmit_requests.sent`
|Counter
|`{requests}`
|Number of retransmit requests sent to other nodes. Indicates this node detected missing messages from senders

|`jgroups.unicast3.xmit_requests.received`
|Counter
|`{requests}`
|Number of retransmit requests received from other nodes. Indicates other nodes are detecting packet loss from this node

|`jgroups.unicast3.acks.sent`
|Counter
|`{acks}`
|Number of acknowledgments sent. Protocol overhead metric

|`jgroups.unicast3.acks.received`
|Counter
|`{acks}`
|Number of acknowledgments received. Protocol overhead metric

|`jgroups.unicast3.connections`
|Gauge
|`{connections}`
|Total number of connections. Connection pool size (send + receive)

|`jgroups.unicast3.connections.send`
|Gauge
|`{connections}`
|Number of active outgoing send connections. Connection pool size for sends

|`jgroups.unicast3.connections.receive`
|Gauge
|`{connections}`
|Number of active incoming receive connections. Connection pool size for receives

|`jgroups.unicast3.messages.unacked`
|Gauge
|`{messages}`
|Number of unacknowledged messages in send windows. *Critical*: Indicates backpressure or slow receivers

|`jgroups.unicast3.xmit_table.missing_messages`
|Gauge
|`{messages}`
|Number of missing (not yet received) messages in receive windows. *Critical*: Indicates gaps in message sequence

|`jgroups.unicast3.xmit_table.undelivered_messages`
|Gauge
|`{messages}`
|Total undelivered messages buffered in all receive windows. Memory pressure and delivery lag indicator
|===


=== STABLE Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.pbcast.stable.stable.sent`
|Counter
|`{messages}`
|Number of STABLE messages sent (digest reports to coordinator).

|`jgroups.pbcast.stable.stable.received`
|Counter
|`{messages}`
|Number of STABLE messages received (digest reports from members).

|`jgroups.pbcast.stable.stability.sent`
|Counter
|`{messages}`
|Number of STABILITY messages sent (garbage collection triggers).

|`jgroups.pbcast.stable.stability.received`
|Counter
|`{messages}`
|Number of STABILITY messages received (garbage collection triggers).

|`jgroups.pbcast.stable.bytes.received`
|Gauge
|`By` (bytes)
|Total bytes accumulated from multicast messages since last STABLE message.

|`jgroups.pbcast.stable.votes`
|Gauge
|`1` (dimensionless)
|Number of STABLE votes received for current digest.

|`jgroups.pbcast.stable.suspended`
|Gauge
|`1` (dimensionless)
|Indicates whether garbage collection is suspended (1=suspended, 0=active).

|`jgroups.pbcast.stable.stable_task.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the stable task is running (1=running, 0=stopped).

|`jgroups.pbcast.stable.gossip.avg`
|Gauge (Configuration)
|`ms`
|Average interval in milliseconds between STABLE gossip messages (0 disables periodic gossip)

|`jgroups.pbcast.stable.bytes.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum bytes from multicast messages before triggering STABLE message (0 disables byte-based triggering)
|===

=== GMS Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.pbcast.gms.views`
|Gauge
|`1` (dimensionless)
|Total number of views installed in this member. View installation tracking indicator

|`jgroups.pbcast.gms.is_coord`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is the current coordinator (1=coordinator, 0=not coordinator). Cluster coordination indicator

|`jgroups.pbcast.gms.is_leaving`
|Gauge
|`1` (dimensionless)
|Indicates whether this member is in the process of leaving (1=leaving, 0=not leaving). Member departure indicator

|`jgroups.pbcast.gms.merge.in_progress`
|Gauge
|`1` (dimensionless)
|Indicates whether a merge is currently in progress (1=merging, 0=not merging). *Critical*: Merge activity indicator

|`jgroups.pbcast.gms.merge.task.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the merge task is currently running (1=running, 0=stopped). Merge task activity indicator

|`jgroups.pbcast.gms.merge.killer.running`
|Gauge
|`1` (dimensionless)
|Indicates whether the merge killer task is currently running (1=running, 0=stopped). Merge timeout task activity indicator

|`jgroups.pbcast.gms.view_handler.queue`
|Gauge
|`1` (dimensionless)
|Number of queued view change requests (JOIN/LEAVE/SUSPECT) waiting to be processed. *Critical*: High values indicate processing backlog

|`jgroups.pbcast.gms.view_handler.suspended`
|Gauge
|`1` (dimensionless)
|Indicates whether the view handler is suspended (1=suspended, 0=active). Handler activity indicator

|`jgroups.pbcast.gms.timeout.join`
|Gauge (Configuration)
|`ms`
|Timeout in milliseconds for join operations

|`jgroups.pbcast.gms.timeout.leave`
|Gauge (Configuration)
|`ms`
|Timeout in milliseconds for leave operations

|`jgroups.pbcast.gms.timeout.merge`
|Gauge (Configuration)
|`ms`
|Timeout in milliseconds to complete merge operations

|`jgroups.pbcast.gms.timeout.view_ack_collection`
|Gauge (Configuration)
|`ms`
|Timeout in milliseconds to wait for all VIEW acks (0 means wait forever)

|`jgroups.pbcast.gms.join_attempts.max`
|Gauge (Configuration)
|`1` (dimensionless)
|Maximum number of join attempts before giving up and becoming singleton (0 means never give up)
|===


=== UFC Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.ufc.credit.requests.received`
|Counter
|`{requests}`
|Number of credit requests received from senders

|`jgroups.ufc.credit.requests.sent`
|Counter
|`{requests}`
|Number of credit requests sent to receivers

|`jgroups.ufc.credit.responses.received`
|Counter
|`{requests}`
|Number of credit responses (replenishments) received from receivers

|`jgroups.ufc.credit.responses.sent`
|Counter
|`{requests}`
|Number of credit responses (replenishments) sent to senders

|`jgroups.ufc.blocked`
|Gauge
|`1` (dimensionless)
|Number of times flow control blocked a sender waiting for credits. *Critical*: High values indicate backpressure

|`jgroups.ufc.blocked.avg`
|Gauge
|`ms` (milliseconds)
|Average time in milliseconds that senders were blocked waiting for credits. *Critical*: High values indicate credit starvation

|`jgroups.ufc.credits.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum number of bytes to send per receiver before credits must be replenished

|`jgroups.ufc.credits.min`
|Gauge (Configuration)
|`By` (bytes)
|Threshold at which a receiver sends more credits to a sender

|`jgroups.ufc.credits.threshold.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Threshold (as percentage of max_credits) at which a receiver sends more credits

|`jgroups.ufc.blocked.max`
|Gauge (Configuration)
|`ms`
|Maximum time in milliseconds to block waiting for credits before sending a replenishment request
|===


=== MFC Protocol Metrics

[cols="3,1,1,5"]
|===
|Metric Name |Type |Unit |Description

|`jgroups.mfc.credit.requests.received`
|Counter
|`{requests}`
|Number of credit requests received from senders

|`jgroups.mfc.credit.requests.sent`
|Counter
|`{requests}`
|Number of credit requests sent to receivers

|`jgroups.mfc.credit.responses.received`
|Counter
|`{requests}`
|Number of credit responses (replenishments) received from receivers

|`jgroups.mfc.credit.responses.sent`
|Counter
|`{requests}`
|Number of credit responses (replenishments) sent to senders

|`jgroups.mfc.blocked`
|Gauge
|`1` (dimensionless)
|Number of times flow control blocked a sender waiting for credits. *Critical*: High values indicate backpressure

|`jgroups.mfc.blocked.avg`
|Gauge
|`ns` (nanoseconds)
|Average time in nanoseconds that senders were blocked waiting for credits. *Critical*: High values indicate credit starvation

|`jgroups.mfc.credits.max`
|Gauge (Configuration)
|`By` (bytes)
|Maximum number of bytes to send per receiver before credits must be replenished

|`jgroups.mfc.credits.min`
|Gauge (Configuration)
|`By` (bytes)
|Threshold at which a receiver sends more credits to a sender

|`jgroups.mfc.credits.threshold.min`
|Gauge (Configuration)
|`1` (dimensionless)
|Threshold (as percentage of max_credits) at which a receiver sends more credits

|`jgroups.mfc.blocked.max`
|Gauge (Configuration)
|`ms`
|Maximum time in milliseconds to block waiting for credits before sending a replenishment request
|===


== Building

[source,bash]
----
./mvnw clean install
----

== Requirements

* Java 17 or higher
* JGroups 5.4.4.Final or higher
* OpenTelemetry Java SDK 1.44.1 or higher

== Future Work

=== Support for Fine-Grained Metric Control

Add support for enabling/disabling individual metrics at runtime:

* Add `enabled` parameter to `@Observable` annotation to allow metrics to be conditionally registered
* Support configuration-based filtering (e.g., via property patterns or metric name prefixes)
* Enable/disable metrics dynamically without requiring code changes or protocol restarts

This would allow users to reduce overhead by disabling metrics they don't need while keeping the annotation metadata in place for documentation purposes.

=== Create an Observability Best Practices Guide

Create comprehensive documentation on monitoring JGroups clusters effectively:

* *Main Performance Indicators*: Document critical metrics to watch for cluster health (e.g., retransmission rates, unacknowledged message counts, database operation failures)
* *Problem Detection Patterns*: Identify metric patterns that indicate specific issues (e.g., high retransmissions suggesting network problems, growing unacked messages indicating backpressure)
* *Remediation Strategies*: Provide actionable solutions for common problems detected through metrics
* *Alert Thresholds*: Recommend baseline alert thresholds for production environments
* *Troubleshooting Workflows*: Step-by-step guides for diagnosing issues using metric correlations
* *Performance Tuning*: Best practices for optimizing JGroups configuration based on observed metrics

This would help operators move from raw metric collection to actionable insights, enabling proactive issue detection and faster incident resolution.

== License

Licensed under the Apache License, Version 2.0. See link:LICENSE[LICENSE] file for details.

== Contributing

Contributions are welcome! Please submit issues and pull requests on GitHub.
